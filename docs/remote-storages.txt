.. _remote_storages:

Remote storages
---------------

In some cases it's useful to use a CDN_ for serving static files such as
those generated by Django Compressor. Due to the way Django Compressor
processes files, it requires the files to be processed (in the
``{% compress %}`` block) to be available in a local file system cache.

Django Compressor provides hooks to automatically have compressed files
pushed to a remote storage backend. Simply set the storage backend
that saves the result to a remote service (see
:attr:`~django.conf.settings.COMPRESS_STORAGE`).

django-storages
^^^^^^^^^^^^^^^

So assuming your CDN is `Amazon S3`_, you can use the boto_ storage backend
from the 3rd party app `django-storages`_. Some required settings are::

    AWS_ACCESS_KEY_ID = 'XXXXXXXXXXXXXXXXXXXXX'
    AWS_SECRET_ACCESS_KEY = 'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX'
    AWS_STORAGE_BUCKET_NAME = 'compressor-test'

Next, you need to specify the new CDN base URL and update the URLs to the
files in your templates which you want to compress::

    COMPRESS_URL = "http://compressor-test.s3.amazonaws.com/"

.. note::

    For staticfiles just set ``STATIC_URL = COMPRESS_URL``

The storage backend to save the compressed files needs to be changed, too::

    COMPRESS_STORAGE = 'storages.backends.s3boto.S3BotoStorage'

Using staticfiles
^^^^^^^^^^^^^^^^^

If you are using Django's staticfiles_ contrib app or the standalone
app django-staticfiles_, you'll need to use a temporary filesystem cache
for Django Compressor to know which files to compress. Since staticfiles
provides a management command to collect static files from various
locations which uses a storage backend, this is where both apps can be
integrated.

#. Make sure the :attr:`~django.conf.settings.COMPRESS_ROOT` and STATIC_ROOT_
   settings are equal since both apps need to look at the same directories
   when to do their job.

#. You need to create a subclass of the remote storage backend you want
   to use; below is an example of the boto S3 storage backend from
   django-storages_::

    from django.core.files.storage import get_storage_class
    from storages.backends.s3boto import S3BotoStorage

    class CachedS3BotoStorage(S3BotoStorage):
        """
        S3 storage backend that saves the files locally, too.
        """
        def __init__(self, *args, **kwargs):
            super(CachedS3BotoStorage, self).__init__(*args, **kwargs)
            self.local_storage = get_storage_class(
                "compressor.storage.CompressorFileStorage")()

        def save(self, name, content):
            name = super(CachedS3BotoStorage, self).save(name, content)
            self.local_storage._save(name, content)
            return name

#. Set your :attr:`~django.conf.settings.COMPRESS_STORAGE` and STATICFILES_STORAGE_
   settings to the dotted path of your custom cached storage backend, e.g.
   ``'mysite.storage.CachedS3BotoStorage'``.

#. To have Django correctly render the URLs to your static files, set the
   STATIC_URL_ setting to the same value as
   :attr:`~django.conf.settings.COMPRESS_URL` (e.g.
   ``"http://compressor-test.s3.amazonaws.com/"``).

Cache Invalidation
^^^^^^^^^^^^^^^^^^

If you are using a CDN like `Amazon Cloudfront`_, files that you store will be
cached for potentially a very long time.  To enable users to see updated files
you will want to invalidate the files stored in the CDN and all caches and proxies between.
The recommended way to invalidate files is to use versioned file names, django-compressor
takes care of this for css and js files by changing the name to a hash of the contents of
the compressed files, but to invalidate images and other files that the css refers to we
need to do more work.

#. If you use Django's staticfiles_ contrib app you can use the CachedStaticFilesStorage_
   storage class by setting your STATICFILES_STORAGE_ to 'django.contrib.staticfiles.storage.CahcedStaticFilesStorage'.

#. If you are using a remote storage backend such as s3 discussed
   above you can use the CachedFilesMixin from Django's staticfiles_ contrib app
   to add a post_process function to collectstatic that will rename all of your
   files with a hash of the files content in the filename, giving you versioned
   file names.  Below is the example from above of the boto S3 storage backend from
   django-storages_ with CachedFilesMixin::

    from django.core.files.storage import get_storage_class
    from django.contrib.staticfiles.storage import CachedFilesMixin
    from storages.backends.s3boto import S3BotoStorage

    class CachedS3BotoStorage(CachedFilesMixin, S3BotoStorage):
        """
        S3 storage backend that saves the files locally, too.
        """
        def __init__(self, *args, **kwargs):
            super(CachedS3BotoStorage, self).__init__(*args, **kwargs)
            self.local_storage = get_storage_class(
                "compressor.storage.CompressorFileStorage")()

        def save(self, name, content):
            name = super(CachedS3BotoStorage, self).save(name, content)
            self.local_storage._save(name, content)
            return name


    class CompressorCachedS3BotoStorage(S3BotoStorage):
        """
        S3 storage backend that saves the files locally, too.
        """
        def __init__(self, *args, **kwargs):
            super(CompressorCachedS3BotoStorage, self).__init__(*args, **kwargs)
            self.local_storage = get_storage_class(
                "compressor.storage.CompressorFileStorage")()

        def save(self, name, content):
            name = super(CompressorCachedS3BotoStorage, self).save(name, content)
            self.local_storage._save(name, content)
            return name

   Set your :attr:`~django.conf.settings.COMPRESS_STORAGE` setting to the
   dotted path of your CompressorCachedS3BotoStorage backend, e.g.
   ``'mysite.storage.CompressorCachedS3BotoStorage'`` and set the STATICFILES_STORAGE_
   setting to the dotted path of your CachedS3BotoStorage backed, e.g.
   ``'mysite.storage.CachedS3BotoStorage'``.  The reason for the two different
   storage backends is because the STATICFILES_STORAGE_ backend should post-process
   the files and create versions with the hash in the filename, we do not want the
   compressor files to be post-processed so we avoid using the CachedFilesMixin in
   that case.

   Finally you have to change the django-storages_ setting AWS_S3_CUSTOM_DOMAIN to
   the domain that you wish to serve your files from, this should be set similar to
   your STATIC_URL_ setting but without the http:// e.g.: ``'xxxxxxxxx.cloudfront.net'``

#. Now that your files will be versioned with a hash in the filename, you have to tell
   django-compressor to change references in the css files to point to the new versioned
   files.  This is done via the CssAbsoluteFilter, which is set to the default for
   :attr:`~django.conf.settings.COMPRESS_CSS_FILTERS`. You must also set the :attr:`~django.conf.settings.COMPRESS_CSS_INVALIDATION_METHOD` setting to ``'filename'`` to tell CssAbsoluteFilter to add a hash of the files contents to the filename.

.. _CDN: http://en.wikipedia.org/wiki/Content_delivery_network
.. _Amazon S3: https://s3.amazonaws.com/
.. _boto: http://boto.cloudhackers.com/
.. _django-storages: http://code.welldev.org/django-storages/
.. _django-staticfiles: http://github.com/jezdez/django-staticfiles/
.. _staticfiles: http://docs.djangoproject.com/en/dev/howto/static-files/
.. _STATIC_ROOT: http://docs.djangoproject.com/en/dev/ref/settings/#static-root
.. _STATIC_URL: http://docs.djangoproject.com/en/dev/ref/settings/#static-url
.. _STATICFILES_STORAGE: http://docs.djangoproject.com/en/dev/ref/contrib/staticfiles/#staticfiles-storage
.. _Amazon Cloudfront: http://aws.amazon.com/cloudfront/
.. _CachedStaticFilesStorage: https://docs.djangoproject.com/en/dev/ref/contrib/staticfiles/#cachedstaticfilesstorage
